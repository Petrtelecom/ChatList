# План реализации функции "AI-ассистент для улучшения промтов"

Детальный план реализации функции улучшения промтов с помощью AI-ассистента.

---

## Этап 1: Подготовка промпта для улучшения (network.py)

### 1.1 Создание промпта-шаблона для улучшения
- [ ] Создать функцию `create_improvement_prompt(original_prompt: str) -> str`
- [ ] Промпт должен запрашивать:
  - Улучшенную версию исходного промта
  - 2-3 варианта переформулировки
  - Адаптацию под разные типы задач (код, анализ, креатив)
- [ ] Структурировать ответ в формате, удобном для парсинга (JSON или маркированный список)

### 1.2 Создание специализированных промптов
- [ ] `create_code_optimization_prompt(prompt: str) -> str` - для оптимизации промтов под задачи программирования
- [ ] `create_analysis_optimization_prompt(prompt: str) -> str` - для оптимизации промтов под аналитические задачи
- [ ] `create_creative_optimization_prompt(prompt: str) -> str` - для оптимизации промтов под креативные задачи

### 1.3 Функция отправки запроса на улучшение
- [ ] Создать функцию `improve_prompt_via_model(model: Model, original_prompt: str) -> Dict`
- [ ] Использовать существующую функцию `send_openrouter_request` из network.py
- [ ] Обработать ответ и извлечь структурированные данные:
  - Улучшенный промт
  - Варианты переформулировки
  - Адаптированные версии (если запрашивались)
- [ ] Обработка ошибок API и таймаутов

---

## Этап 2: Парсинг ответа от модели

### 2.1 Создание класса для хранения результатов улучшения
- [ ] Создать класс `PromptImprovementResult` в network.py или отдельном модуле
- [ ] Поля класса:
  - `original_prompt: str` - исходный промт
  - `improved_prompt: str` - улучшенная версия
  - `alternatives: List[str]` - список альтернативных вариантов (2-3 шт)
  - `code_version: Optional[str]` - версия для задач программирования
  - `analysis_version: Optional[str]` - версия для аналитических задач
  - `creative_version: Optional[str]` - версия для креативных задач
  - `model_name: str` - название модели, которая выполнила улучшение
  - `error: Optional[str]` - ошибка, если была

### 2.2 Парсинг структурированного ответа
- [ ] Создать функцию `parse_improvement_response(response_text: str, original_prompt: str, model_name: str) -> PromptImprovementResult`
- [ ] Реализовать парсинг JSON-ответа (если модель возвращает JSON)
- [ ] Реализовать парсинг текстового ответа с маркированными списками
- [ ] Обработка случаев, когда модель не вернула структурированный ответ
- [ ] Валидация наличия обязательных полей (улучшенный промт)

---

## Этап 3: Выбор модели для улучшения

### 3.1 Добавление настройки модели по умолчанию
- [ ] Добавить в таблицу `settings` БД настройку `improvement_model_id` (ID модели для улучшения)
- [ ] Создать функцию `db.get_improvement_model_id() -> Optional[int]`
- [ ] Создать функцию `db.set_improvement_model_id(model_id: int)`
- [ ] При инициализации БД установить модель по умолчанию (например, первая активная модель)

### 3.2 UI для выбора модели улучшения
- [ ] Добавить в диалог настроек (или создать отдельный диалог) выбор модели для улучшения
- [ ] Выпадающий список с активными моделями
- [ ] Сохранение выбранной модели в БД

---

## Этап 4: Создание диалогового окна улучшения промта

### 4.1 Создание класса диалога
- [ ] Создать класс `PromptImprovementDialog(QDialog)` в main.py
- [ ] Наследование от QDialog
- [ ] Модальное окно с фиксированным размером (например, 800x600)

### 4.2 Структура интерфейса диалога
- [ ] **Область исходного промта:**
  - [ ] QLabel "Исходный промт:"
  - [ ] QTextEdit (только для чтения) с исходным промтом
- [ ] **Область улучшенного промта:**
  - [ ] QLabel "Улучшенный промт:"
  - [ ] QTextEdit (редактируемый) с улучшенной версией
  - [ ] Кнопка "Копировать" для копирования в буфер обмена
- [ ] **Область альтернативных вариантов:**
  - [ ] QLabel "Альтернативные варианты:"
  - [ ] QListWidget или QTextEdit с вариантами (2-3 варианта)
  - [ ] Кнопка "Использовать этот вариант" для каждого варианта
- [ ] **Область адаптированных версий (опционально):**
  - [ ] QTabWidget с вкладками: "Код", "Анализ", "Креатив"
  - [ ] В каждой вкладке - QTextEdit с соответствующей версией
  - [ ] Кнопка "Использовать" в каждой вкладке

### 4.3 Кнопки управления
- [ ] Кнопка "Подставить в поле ввода" - заменяет текст в основном поле ввода промта
- [ ] Кнопка "Закрыть" - закрывает диалог
- [ ] Индикатор загрузки (QProgressBar или QLabel) во время обработки запроса

### 4.4 Обработка ошибок в диалоге
- [ ] Отображение сообщений об ошибках через QMessageBox
- [ ] Обработка случая, когда модель не выбрана
- [ ] Обработка ошибок API (таймауты, неверные ключи)

---

## Этап 5: Интеграция в главное окно

### 5.1 Добавление кнопки "Улучшить промт"
- [ ] В методе `create_prompt_panel()` добавить кнопку "Улучшить промт"
- [ ] Разместить кнопку рядом с полем ввода промта (например, в том же layout, что и "Новый промт" и "Сохранить промт")
- [ ] Стилизация кнопки (например, другой цвет для выделения)

### 5.2 Обработчик нажатия кнопки
- [ ] Создать метод `on_improve_prompt_clicked()` в классе MainWindow
- [ ] Проверка наличия текста в поле промта (если пусто - показать предупреждение)
- [ ] Получение выбранной модели для улучшения из БД
- [ ] Если модель не выбрана - показать диалог выбора модели
- [ ] Открытие диалога `PromptImprovementDialog` с текущим промтом

### 5.3 Обработка результата из диалога
- [ ] При нажатии "Подставить в поле ввода" в диалоге:
  - [ ] Получить выбранный/улучшенный промт из диалога
  - [ ] Заменить текст в `self.prompt_text`
  - [ ] Закрыть диалог

---

## Этап 6: Асинхронная обработка запроса

### 6.1 Создание потока для улучшения промта
- [ ] Создать класс `ImprovementThread(QThread)` в main.py
- [ ] Сигналы:
  - `finished(result: PromptImprovementResult)` - успешное завершение
  - `error(error_message: str)` - ошибка при обработке
  - `progress(message: str)` - сообщение о прогрессе (опционально)

### 6.2 Интеграция потока в диалог
- [ ] В `PromptImprovementDialog` создать экземпляр `ImprovementThread`
- [ ] При открытии диалога запускать поток асинхронно
- [ ] Показывать индикатор загрузки во время работы потока
- [ ] Блокировать кнопки управления до получения результата
- [ ] При получении результата обновить интерфейс диалога

### 6.3 Обработка отмены запроса
- [ ] Добавить возможность отмены запроса (кнопка "Отмена" во время загрузки)
- [ ] Корректное завершение потока при отмене

---

## Этап 7: Дополнительные функции

### 7.1 Кэширование результатов
- [ ] (Опционально) Кэшировать результаты улучшения для одинаковых промтов
- [ ] Хранение в памяти или временной БД
- [ ] Проверка кэша перед отправкой запроса

### 7.2 История улучшений
- [ ] (Опционально) Сохранение истории улучшений в БД
- [ ] Таблица `prompt_improvements` с полями:
  - `id`, `original_prompt`, `improved_prompt`, `model_id`, `created_at`
- [ ] Возможность просмотра истории в диалоге

### 7.3 Настройки улучшения
- [ ] Добавить настройки в диалог:
  - [ ] Чекбокс "Включать адаптированные версии" (код/анализ/креатив)
  - [ ] Количество альтернативных вариантов (2 или 3)
  - [ ] Температура модели для улучшения (если поддерживается)

---

## Этап 8: Тестирование

### 8.1 Функциональное тестирование
- [ ] Тестирование функции `improve_prompt_via_model` с разными моделями
- [ ] Тестирование парсинга ответов от разных моделей
- [ ] Тестирование обработки ошибок (неверный API ключ, таймаут, ошибка сети)
- [ ] Тестирование работы с пустым промтом

### 8.2 Тестирование UI
- [ ] Тестирование открытия диалога из главного окна
- [ ] Тестирование кнопки "Подставить в поле ввода"
- [ ] Тестирование выбора альтернативных вариантов
- [ ] Тестирование работы с длинными промтами
- [ ] Тестирование отмены запроса

### 8.3 Интеграционное тестирование
- [ ] Тестирование полного цикла: ввод промта → улучшение → использование улучшенного промта → отправка запроса
- [ ] Тестирование сохранения настроек модели для улучшения

---

## Этап 9: Оптимизация и улучшения

### 9.1 Оптимизация промпта
- [ ] Экспериментирование с разными формулировками промпта для улучшения
- [ ] Тестирование на различных типах промтов (короткие, длинные, технические, креативные)
- [ ] Оптимизация структуры ответа для лучшего парсинга

### 9.2 Улучшение UX
- [ ] Добавление подсказок и tooltips в диалоге
- [ ] Улучшение визуального оформления (цвета, шрифты, отступы)
- [ ] Добавление анимации загрузки (если возможно)

### 9.3 Обработка edge cases
- [ ] Обработка очень длинных промтов (обрезка или предупреждение)
- [ ] Обработка промтов на разных языках
- [ ] Обработка промтов с специальными символами

---

## Приоритет реализации

**Высокий приоритет (необходимо для базовой работы):**
- Этапы 1-5: Базовая функциональность улучшения промтов и интеграция в UI

**Средний приоритет (важно для удобства использования):**
- Этап 6: Асинхронная обработка для лучшего UX
- Этап 7.1-7.2: Кэширование и история (опционально)

**Низкий приоритет (можно добавить позже):**
- Этап 7.3: Расширенные настройки
- Этап 9: Оптимизация и улучшения

---

## Примечания

- Все функции должны быть независимыми и легко тестируемыми
- Использовать существующую инфраструктуру (network.py, db.py, models.py)
- Код должен быть читаемым и документированным
- При работе с UI использовать сигналы и слоты PyQt для асинхронности
- Обрабатывать все возможные ошибки и показывать понятные сообщения пользователю

